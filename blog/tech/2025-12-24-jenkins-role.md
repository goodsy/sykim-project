---
title: Jenkins 연계 구조와 설계
description: Jenkins, Quartz(Scheduled), Spring Batch의 역할 경계와 연계 방식
tags: [tech]
---

# Jenkins 연계 구조와 설계
_Jenkins · Quartz(Scheduled) · Spring Batch의 역할 경계_

이전 글에서 [왜 Jenkins를 도입하는가](./2025-12-17-jenkins-intruduce.md)를 운영 경험을 중심으로 정리했다.

배치가 단순히 “정해진 시간에 잘 도는 것”보다  
**장애가 발생했을 때 어떻게 대응할 수 있는지**,  
**누가 어떤 기준으로 재실행할 수 있는지**가 점점 더 중요해졌기 때문이다.

이번 글에서는  
Jenkins를 실제로 도입하면서  
**각 컴포넌트의 역할을 어디까지로 정의했는지**,  
그리고 **왜 그 경계가 중요했는지**를 정리해보려 한다.

이 글에서 말하고 싶은 핵심은 하나다.

> **Jenkins가 모든 것을 하지 않게 만드는 것**

---

## 전체 구조 개요

Jenkins를 도입하면서 가장 먼저 고민한 것은  
“어떤 기술을 더 쓸 것인가”가 아니라  
**“각 구성 요소가 무엇을 책임질 것인가”**였다.

배치 플랫폼의 구조는 아래와 같이 가져갔다.

```plaintext
[Jenkins]
    ↓ (Trigger / Parameter)
[Batch Application]
    ├─ Quartz / Scheduled (내부 스케줄)
    └─ Spring Batch (실제 처리)
```

---

## 각 컴포넌트의 역할 정의

### Jenkins의 역할

Jenkins의 역할은 명확하다.
배치를 **실행**하는 것까지만 책임진다.

- 배치 실행 트리거
- 실행 파라미터 전달
- 실행 이력 관리
- 실패 감지 및 재실행

반대로, Jenkins가 하면 안 되는 일도 분명히 정했다.

- 비즈니스 로직 처리
- 데이터 가공 및 검증
- 배치 성공/실패의 최종 판단

Jenkins는 배치가 왜 실패했는지를 판단하지 않는다.
단지 실행 결과를 보여주고, 다시 실행할 수 있게 해주는 역할만 수행한다.

이 선을 넘기기 시작하면  Jenkins는 운영 도구가 아니라 로직이 쌓이는 또 하나의 애플리케이션이 된다.

---

### Spring Batch의 역할

Spring Batch는 이 구조에서 **상태와 데이터** 중심의 역할을 한다.

- Job / Step 실행
- JobExecution 상태 관리
- Restart / Skip / Retry 처리
- 트랜잭션 관리

배치가 어디까지 실행됐는지,
재시작이 가능한지,
어떤 Step에서 실패했는지는
항상 Spring Batch 기준으로 판단한다.

Jenkins의 성공/실패 표시는 참고 정보일 뿐이며, 배치의 “진짜 상태”는 Spring Batch가 관리한다.
이 기준이 흔들리면 재처리 판단 역시 함께 흔들릴 수밖에 없다.

---

### Quartz, Scheduled의 역할

Quartz나 @Scheduled는 완전히 제거하지 않았다.
다만 역할을 명확히 제한했다.

- 애플리케이션 내부 정책성 스케줄
- 일정 시간 지연 후 처리
- 주기적인 내부 후처리 작업

즉, Quartz와 Scheduled는
운영자가 직접 실행하고 제어하는 배치가 아니라,
애플리케이션 내부 흐름을 보조하는 역할만 담당한다.

> Jenkins가 “언제 운영적으로 실행할지”를 책임진다면
> Quartz와 Scheduled는 “애플리케이션 내부에서 언제 처리할지”를 담당한다.


---

## Jenkins → Batch 실행 흐름

일반적인 실행 흐름은 다음과 같다.

1. 운영자가 Jenkins Job을 실행한다.
2. 실행에 필요한 파라미터(일자, 대상 등)를 입력한다.
3. Jenkins가 Batch Application을 호출한다.
4. Application 내부에서 Spring Batch Job이 실행된다.
5. 실행 결과를 Jenkins에서 확인한다. 

이 흐름에서 중요한 점은 하나다.

> Jenkins는 실행을 요청할 뿐이고, 성공/실패의 판단 기준은 Batch에 있다.

이 구조 덕분에  운영과 실행 책임이 자연스럽게 분리된다.

---

## 장애 상황에서의 동작 방식

### 서버 장애 발생 시

배치 실행 중 서버 장애가 발생하더라도, Jenkins는 계속 살아 있고
장애가 발생한 것은 특정 배치 서버뿐이며 다른 서버로 재실행이 가능하다

즉,

> 서버 장애가 곧 전체 배치 중단으로 이어지지 않는다


---

### 배치 로직 실패 시

반대로 서버는 정상인데 배치 로직이 실패한 경우에는,

- 애플리케이션은 정상 기동 상태
- Spring Batch 기준 JobExecution FAILED
- 원인 분석 후 재실행 진행

운영자는 이 장애가 환경 문제인지, 데이터/로직 문제인지를 빠르게 구분할 수 있다.

---

## Jenkins와 Quartz, Scheduled의 경계

이 구조에서 가장 중요한 부분이다.

** Jenkins가 하면 안 되는 것

- 배치 조건 분기
- 정책 판단
- 데이터 검증 로직
- 비즈니스 흐름 제어

이런 로직이 Jenkins로 넘어가는 순간, 운영 스크립트는 기술 부채가 된다.

---

### Quartz, Scheduled가 하면 안 되는 것

- 외부 운영 스케줄 대체
- 재처리 판단
- 수동 실행 책임

Quartz와 Scheduled는 운영 배치를 대신하는 도구가 아니다.
**내부 보조 스케줄러** 역할에만 집중해야 한다.


---

## 정리

이 구조에서의 핵심은 명확하다.

- Jenkins: 운영 관점의 실행 컨트롤러
- Quartz / Scheduled: 내부 정책성 스케줄
- Spring Batch: 배치 처리와 상태의 기준

역할을 명확히 나누었기 때문에  Jenkins는 강력한 운영 도구가 되었고,
새로운 기술 부채로 번지지 않을 수 있었다.

---

> Jenkins는 배치를 실행하고,  
> Spring Batch는 배치를 책임진다.
